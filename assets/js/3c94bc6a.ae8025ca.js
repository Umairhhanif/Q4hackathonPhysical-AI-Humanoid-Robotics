"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[904],{5395:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module-04-vla/week-12-kinematics","title":"Week 12: Kinematics & Dynamics","description":"Mastering the Mathematical Foundations of Humanoid Movement","source":"@site/docs/module-04-vla/week-12-kinematics.md","sourceDirName":"module-04-vla","slug":"/module-04-vla/week-12-kinematics","permalink":"/docs/module-04-vla/week-12-kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-04-vla/week-12-kinematics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Week 12: Kinematics & Dynamics","sidebar_position":2},"sidebar":"modulesSidebar","previous":{"title":"Week 11: Humanoid Development","permalink":"/docs/module-04-vla/week-11-humanoid"},"next":{"title":"Week 13: Conversational Robotics","permalink":"/docs/module-04-vla/week-13-robotics"}}');var s=t(4848),r=t(8453);const a={title:"Week 12: Kinematics & Dynamics",sidebar_position:2},i="Week 12: Kinematics and Dynamics - The Mathematics of Motion",l={},d=[{value:"Mastering the Mathematical Foundations of Humanoid Movement",id:"mastering-the-mathematical-foundations-of-humanoid-movement",level:2},{value:"Forward Kinematics: From Joints to End-Effector",id:"forward-kinematics-from-joints-to-end-effector",level:2},{value:"Homogeneous Transformations",id:"homogeneous-transformations",level:3},{value:"Humanoid Kinematics Implementation",id:"humanoid-kinematics-implementation",level:3},{value:"Inverse Kinematics: From End-Effector to Joints",id:"inverse-kinematics-from-end-effector-to-joints",level:2},{value:"Analytical Solutions",id:"analytical-solutions",level:3},{value:"Numerical Methods",id:"numerical-methods",level:3},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:2},{value:"Newton-Euler Equations",id:"newton-euler-equations",level:3},{value:"Multi-Body Dynamics",id:"multi-body-dynamics",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:2},{value:"Task-Space Control",id:"task-space-control",level:3},{value:"\ud83c\udfaf Weekly Project: Complete Kinematics and Dynamics System",id:"-weekly-project-complete-kinematics-and-dynamics-system",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"week-12-kinematics-and-dynamics---the-mathematics-of-motion",children:"Week 12: Kinematics and Dynamics - The Mathematics of Motion"})}),"\n",(0,s.jsx)(e.h2,{id:"mastering-the-mathematical-foundations-of-humanoid-movement",children:"Mastering the Mathematical Foundations of Humanoid Movement"}),"\n",(0,s.jsx)(e.p,{children:"This week dives deep into the mathematical foundations that enable precise control of humanoid robots. You'll learn forward and inverse kinematics, rigid body dynamics, and multi-body system modeling\u2014essential tools for controlling complex robotic systems with human-like dexterity. Through mathematical analysis and practical implementation, you'll understand how to model, analyze, and control the sophisticated movements that make humanoid robots possible."}),"\n",(0,s.jsx)(e.h2,{id:"forward-kinematics-from-joints-to-end-effector",children:"Forward Kinematics: From Joints to End-Effector"}),"\n",(0,s.jsx)(e.h3,{id:"homogeneous-transformations",children:"Homogeneous Transformations"}),"\n",(0,s.jsx)(e.p,{children:"The foundation of robotic kinematics lies in coordinate transformations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\nclass HomogeneousTransform:\n    """Homogeneous transformation matrix utilities"""\n    \n    @staticmethod\n    def rotation_x(theta):\n        """Rotation matrix around X axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [1, 0, 0, 0],\n            [0, c, -s, 0],\n            [0, s, c, 0],\n            [0, 0, 0, 1]\n        ])\n    \n    @staticmethod\n    def rotation_y(theta):\n        """Rotation matrix around Y axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [c, 0, s, 0],\n            [0, 1, 0, 0],\n            [-s, 0, c, 0],\n            [0, 0, 0, 1]\n        ])\n    \n    @staticmethod\n    def rotation_z(theta):\n        """Rotation matrix around Z axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [c, -s, 0, 0],\n            [s, c, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n    \n    @staticmethod\n    def translation(x, y, z):\n        """Translation matrix"""\n        return np.array([\n            [1, 0, 0, x],\n            [0, 1, 0, y],\n            [0, 0, 1, z],\n            [0, 0, 0, 1]\n        ])\n    \n    @staticmethod\n    def dh_transform(a, alpha, d, theta):\n        """Denavit-Hartenberg transformation"""\n        return HomogeneousTransform.rotation_x(alpha) @ \\\n               HomogeneousTransform.translation(a, 0, 0) @ \\\n               HomogeneousTransform.rotation_z(theta) @ \\\n               HomogeneousTransform.translation(0, 0, d)\n\nclass SerialManipulator:\n    """Forward kinematics for serial manipulators"""\n    \n    def __init__(self, dh_parameters):\n        """\n        Initialize with DH parameters\n        dh_parameters: list of (a, alpha, d, theta_offset) tuples\n        """\n        self.dh_params = dh_parameters\n        self.num_joints = len(dh_parameters)\n    \n    def forward_kinematics(self, joint_angles):\n        """Compute end-effector pose from joint angles"""\n        \n        if len(joint_angles) != self.num_joints:\n            raise ValueError(f"Expected {self.num_joints} joint angles, got {len(joint_angles)}")\n        \n        # Start with identity matrix\n        transform = np.eye(4)\n        \n        # Apply DH transformations sequentially\n        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):\n            theta = joint_angles[i] + theta_offset\n            dh_matrix = HomogeneousTransform.dh_transform(a, alpha, d, theta)\n            transform = transform @ dh_matrix\n        \n        return transform\n    \n    def get_link_transforms(self, joint_angles):\n        """Get transformation matrices for all links"""\n        \n        transforms = []\n        current_transform = np.eye(4)\n        \n        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):\n            theta = joint_angles[i] + theta_offset\n            dh_matrix = HomogeneousTransform.dh_transform(a, alpha, d, theta)\n            current_transform = current_transform @ dh_matrix\n            transforms.append(current_transform.copy())\n        \n        return transforms\n'})}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-kinematics-implementation",children:"Humanoid Kinematics Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class HumanoidKinematics:\n    """Complete kinematics for humanoid robot"""\n    \n    def __init__(self):\n        # Define kinematic chains for different parts\n        self.left_leg = SerialManipulator(self.get_leg_dh_params())\n        self.right_leg = SerialManipulator(self.get_leg_dh_params())\n        self.left_arm = SerialManipulator(self.get_arm_dh_params())\n        self.right_arm = SerialManipulator(self.get_arm_dh_params())\n        self.torso = SerialManipulator(self.get_torso_dh_params())\n        self.head = SerialManipulator(self.get_head_dh_params())\n        \n        # Base transformation (floating base)\n        self.base_transform = np.eye(4)\n    \n    def get_leg_dh_params(self):\n        """DH parameters for humanoid leg (6 DOF)"""\n        return [\n            (0, np.pi/2, 0, 0),      # Hip yaw\n            (0, -np.pi/2, 0, 0),     # Hip roll\n            (0, np.pi/2, 0, np.pi/2), # Hip pitch\n            (0, 0, -0.4, 0),         # Knee pitch\n            (0, 0, -0.4, 0),         # Ankle pitch\n            (0, -np.pi/2, 0, 0)      # Ankle roll\n        ]\n    \n    def get_arm_dh_params(self):\n        """DH parameters for humanoid arm (7 DOF)"""\n        return [\n            (0, np.pi/2, 0, 0),      # Shoulder yaw\n            (0, -np.pi/2, 0, 0),     # Shoulder pitch\n            (0, -np.pi/2, 0, 0),     # Shoulder roll\n            (0, np.pi/2, -0.3, 0),   # Elbow pitch\n            (0, -np.pi/2, 0, 0),     # Wrist yaw\n            (0, np.pi/2, 0, 0),      # Wrist pitch\n            (0, 0, -0.15, 0)         # Wrist roll\n        ]\n    \n    def forward_kinematics_full(self, joint_angles, base_pose=None):\n        """Compute poses for all end-effectors"""\n        \n        if base_pose is not None:\n            self.base_transform = self.pose_to_transform(base_pose)\n        \n        # Unpack joint angles\n        angles = self.unpack_joint_angles(joint_angles)\n        \n        # Compute end-effector poses\n        left_foot_pose = self.compute_foot_pose(\'left\', angles[\'left_leg\'])\n        right_foot_pose = self.compute_foot_pose(\'right\', angles[\'right_leg\'])\n        left_hand_pose = self.compute_hand_pose(\'left\', angles[\'left_arm\'])\n        right_hand_pose = self.compute_hand_pose(\'right\', angles[\'right_arm\'])\n        head_pose = self.compute_head_pose(angles[\'head\'])\n        \n        return {\n            \'left_foot\': left_foot_pose,\n            \'right_foot\': right_foot_pose,\n            \'left_hand\': left_hand_pose,\n            \'right_hand\': right_hand_pose,\n            \'head\': head_pose\n        }\n    \n    def compute_foot_pose(self, side, leg_angles):\n        """Compute foot pose relative to base"""\n        \n        if side == \'left\':\n            leg_transform = self.left_leg.forward_kinematics(leg_angles)\n            # Apply left leg offset\n            leg_offset = HomogeneousTransform.translation(0.1, 0.1, 0)\n        else:\n            leg_transform = self.right_leg.forward_kinematics(leg_angles)\n            # Apply right leg offset\n            leg_offset = HomogeneousTransform.translation(0.1, -0.1, 0)\n        \n        return self.base_transform @ leg_offset @ leg_transform\n    \n    def compute_hand_pose(self, side, arm_angles):\n        """Compute hand pose relative to base"""\n        \n        # Torso transform\n        torso_transform = self.torso.forward_kinematics([0])  # Simplified\n        \n        if side == \'left\':\n            arm_transform = self.left_arm.forward_kinematics(arm_angles)\n            arm_offset = HomogeneousTransform.translation(0.2, 0.2, 0.4)\n        else:\n            arm_transform = self.right_arm.forward_kinematics(arm_angles)\n            arm_offset = HomogeneousTransform.translation(0.2, -0.2, 0.4)\n        \n        return self.base_transform @ torso_transform @ arm_offset @ arm_transform\n'})}),"\n",(0,s.jsx)(e.h2,{id:"inverse-kinematics-from-end-effector-to-joints",children:"Inverse Kinematics: From End-Effector to Joints"}),"\n",(0,s.jsx)(e.h3,{id:"analytical-solutions",children:"Analytical Solutions"}),"\n",(0,s.jsx)(e.p,{children:"For simple manipulators, closed-form solutions exist:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class TwoLinkIK:\n    """Analytical inverse kinematics for 2-link planar arm"""\n    \n    def __init__(self, link_lengths):\n        self.l1, self.l2 = link_lengths\n    \n    def solve(self, target_x, target_y):\n        """Solve IK for 2-link arm"""\n        \n        # Distance to target\n        dist = np.sqrt(target_x**2 + target_y**2)\n        \n        # Check reachability\n        if dist > (self.l1 + self.l2) or dist < abs(self.l1 - self.l2):\n            return None  # Target unreachable\n        \n        # Elbow angle (cosine rule)\n        cos_elbow = (dist**2 - self.l1**2 - self.l2**2) / (2 * self.l1 * self.l2)\n        elbow_angle = np.arccos(np.clip(cos_elbow, -1, 1))\n        \n        # Shoulder angle\n        shoulder_angle = np.arctan2(target_y, target_x) - \\\n                        np.arctan2(self.l2 * np.sin(elbow_angle),\n                                 self.l1 + self.l2 * np.cos(elbow_angle))\n        \n        return [shoulder_angle, elbow_angle]\n\nclass HumanoidArmIK:\n    """Inverse kinematics for humanoid arm"""\n    \n    def __init__(self):\n        self.shoulder_pos = np.array([0.2, 0.2, 0.4])  # Relative to torso\n        self.upper_arm_length = 0.3\n        self.forearm_length = 0.25\n        self.hand_offset = 0.15\n        \n        # 7-DOF arm: 3 shoulder + 1 elbow + 3 wrist\n        self.dof = 7\n    \n    def solve(self, target_pose, current_angles=None):\n        """Solve IK for 7-DOF humanoid arm"""\n        \n        # Extract position and orientation\n        target_pos = target_pose[:3, 3]\n        target_rot = target_pose[:3, :3]\n        \n        # Step 1: Solve for wrist position\n        wrist_pos = target_pos - target_rot @ np.array([0, 0, -self.hand_offset])\n        \n        # Step 2: Solve 3-DOF shoulder IK\n        shoulder_angles = self.solve_shoulder_ik(wrist_pos - self.shoulder_pos)\n        \n        # Step 3: Solve 2-DOF elbow IK\n        elbow_angles = self.solve_elbow_ik(wrist_pos - self.shoulder_pos, shoulder_angles)\n        \n        # Step 4: Solve 3-DOF wrist IK for orientation\n        wrist_angles = self.solve_wrist_ik(target_rot, shoulder_angles + elbow_angles)\n        \n        return shoulder_angles + elbow_angles + wrist_angles\n    \n    def solve_shoulder_ik(self, shoulder_to_wrist):\n        """Solve 3-DOF shoulder inverse kinematics"""\n        \n        # Spherical coordinates\n        r = np.linalg.norm(shoulder_to_wrist)\n        theta = np.arctan2(shoulder_to_wrist[1], shoulder_to_wrist[0])\n        phi = np.arccos(shoulder_to_wrist[2] / r)\n        \n        return [theta, phi, 0]  # Simplified\n    \n    def solve_elbow_ik(self, shoulder_to_wrist, shoulder_angles):\n        """Solve 2-DOF elbow inverse kinematics"""\n        \n        # Project to shoulder plane\n        wrist_proj = self.project_to_shoulder_plane(shoulder_to_wrist, shoulder_angles)\n        \n        # 2-link IK in plane\n        ik_solver = TwoLinkIK([self.upper_arm_length, self.forearm_length])\n        solution = ik_solver.solve(wrist_proj[0], wrist_proj[1])\n        \n        return solution if solution else [0, 0]\n    \n    def solve_wrist_ik(self, target_rot, arm_angles):\n        """Solve 3-DOF wrist inverse kinematics"""\n        \n        # Compute current arm orientation\n        arm_rot = self.forward_kinematics_arm(arm_angles)[:3, :3]\n        \n        # Desired wrist rotation relative to arm\n        wrist_rot = arm_rot.T @ target_rot\n        \n        # Extract Euler angles\n        roll = np.arctan2(wrist_rot[2, 1], wrist_rot[2, 2])\n        pitch = np.arctan2(-wrist_rot[2, 0], \n                          np.sqrt(wrist_rot[2, 1]**2 + wrist_rot[2, 2]**2))\n        yaw = np.arctan2(wrist_rot[1, 0], wrist_rot[1, 0])\n        \n        return [roll, pitch, yaw]\n'})}),"\n",(0,s.jsx)(e.h3,{id:"numerical-methods",children:"Numerical Methods"}),"\n",(0,s.jsx)(e.p,{children:"For complex kinematics, numerical optimization is necessary:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import scipy.optimize\n\nclass NumericalIK:\n    """Numerical inverse kinematics solver"""\n    \n    def __init__(self, forward_kinematics_func, num_joints):\n        self.fk_func = forward_kinematics_func\n        self.num_joints = num_joints\n        \n        # Joint limits\n        self.joint_limits = [(-np.pi, np.pi) for _ in range(num_joints)]\n    \n    def solve(self, target_pose, initial_guess=None, max_iterations=100):\n        """Solve IK using numerical optimization"""\n        \n        if initial_guess is None:\n            initial_guess = np.zeros(self.num_joints)\n        \n        def objective(joint_angles):\n            """Minimize pose error"""\n            current_pose = self.fk_func(joint_angles)\n            error = self.pose_error(current_pose, target_pose)\n            return error\n        \n        def constraint(joint_angles):\n            """Enforce joint limits"""\n            return np.array([\n                joint_angles - np.array([lim[0] for lim in self.joint_limits]),\n                np.array([lim[1] for lim in self.joint_limits]) - joint_angles\n            ]).flatten()\n        \n        # Bounds for optimization\n        bounds = self.joint_limits\n        \n        # Solve optimization problem\n        result = scipy.optimize.minimize(\n            objective,\n            initial_guess,\n            method=\'SLSQP\',\n            bounds=bounds,\n            constraints={\'type\': \'ineq\', \'fun\': constraint},\n            options={\'maxiter\': max_iterations, \'ftol\': 1e-6}\n        )\n        \n        if result.success:\n            return result.x\n        else:\n            return None\n    \n    def pose_error(self, current_pose, target_pose):\n        """Compute pose error for optimization"""\n        \n        # Position error\n        pos_error = np.linalg.norm(current_pose[:3, 3] - target_pose[:3, 3])\n        \n        # Orientation error (angle between rotation matrices)\n        rot_error = np.arccos(\n            np.clip((np.trace(current_pose[:3, :3].T @ target_pose[:3, :3]) - 1) / 2, -1, 1)\n        )\n        \n        # Combined error\n        return pos_error + 0.1 * rot_error  # Weight orientation less\n'})}),"\n",(0,s.jsx)(e.h2,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,s.jsx)(e.h3,{id:"newton-euler-equations",children:"Newton-Euler Equations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class RigidBodyDynamics:\n    """Dynamics computation for rigid bodies"""\n    \n    def __init__(self, mass, inertia_tensor, com_offset):\n        self.mass = mass\n        self.inertia = inertia_tensor\n        self.com_offset = com_offset  # Offset from joint to center of mass\n        \n        # State variables\n        self.position = np.zeros(3)\n        self.orientation = np.eye(3)\n        self.velocity = np.zeros(3)\n        self.angular_velocity = np.zeros(3)\n    \n    def compute_accelerations(self, force, torque, gravity=np.array([0, 0, -9.81])):\n        """Compute linear and angular accelerations"""\n        \n        # Linear acceleration (F = ma)\n        linear_acceleration = (force + self.mass * gravity) / self.mass\n        \n        # Angular acceleration (\u03c4 = I\u03b1 + \u03c9 \xd7 I\u03c9)\n        omega = self.angular_velocity\n        coriolis_term = np.cross(omega, self.inertia @ omega)\n        angular_acceleration = np.linalg.inv(self.inertia) @ (torque - coriolis_term)\n        \n        return linear_acceleration, angular_acceleration\n    \n    def integrate_step(self, linear_acc, angular_acc, dt):\n        """Integrate accelerations to update state"""\n        \n        # Update velocities\n        self.velocity += linear_acc * dt\n        self.angular_velocity += angular_acc * dt\n        \n        # Update positions\n        self.position += self.velocity * dt\n        \n        # Update orientation (simplified Euler integration)\n        omega_magnitude = np.linalg.norm(self.angular_velocity)\n        if omega_magnitude > 0:\n            axis = self.angular_velocity / omega_magnitude\n            angle = omega_magnitude * dt\n            delta_rot = self.axis_angle_to_matrix(axis, angle)\n            self.orientation = delta_rot @ self.orientation\n    \n    def axis_angle_to_matrix(self, axis, angle):\n        """Convert axis-angle to rotation matrix"""\n        axis = axis / np.linalg.norm(axis)\n        a = np.cos(angle / 2)\n        b, c, d = -axis * np.sin(angle / 2)\n        \n        return np.array([\n            [a*a + b*b - c*c - d*d, 2*(b*c - a*d), 2*(b*d + a*c)],\n            [2*(b*c + a*d), a*a + c*c - b*b - d*d, 2*(c*d - a*b)],\n            [2*(b*d - a*c), 2*(c*d + a*b), a*a + d*d - b*b - c*c]\n        ])\n'})}),"\n",(0,s.jsx)(e.h3,{id:"multi-body-dynamics",children:"Multi-Body Dynamics"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class MultiBodyDynamics:\n    """Dynamics for articulated multi-body systems"""\n    \n    def __init__(self, bodies, joints):\n        self.bodies = bodies  # List of RigidBodyDynamics objects\n        self.joints = joints  # Joint definitions\n        \n        # System state\n        self.q = np.zeros(self.get_num_dof())  # Joint positions\n        self.qd = np.zeros(self.get_num_dof()) # Joint velocities\n    \n    def get_num_dof(self):\n        """Get total degrees of freedom"""\n        return sum(len(joint.dof) for joint in self.joints)\n    \n    def compute_mass_matrix(self, q):\n        """Compute system mass matrix M(q)"""\n        \n        n = self.get_num_dof()\n        M = np.zeros((n, n))\n        \n        # This is a simplified implementation\n        # Real implementation requires recursive algorithms\n        for i, body in enumerate(self.bodies):\n            # Add body inertia to mass matrix\n            body_inertia = body.mass * np.eye(3)  # Simplified\n            M[i*3:(i+1)*3, i*3:(i+1)*3] += body_inertia\n        \n        return M\n    \n    def compute_coriolis_matrix(self, q, qd):\n        """Compute Coriolis and centrifugal forces C(q,qd)"""\n        \n        n = self.get_num_dof()\n        C = np.zeros((n, n))\n        \n        # Simplified - real implementation is complex\n        # Involves Christoffel symbols and recursive calculations\n        return C\n    \n    def compute_gravity_vector(self, q):\n        """Compute gravity force vector G(q)"""\n        \n        n = self.get_num_dof()\n        G = np.zeros(n)\n        \n        for i, body in enumerate(self.bodies):\n            # Gravity acts at center of mass\n            gravity_force = body.mass * np.array([0, 0, -9.81])\n            # Convert to joint torques (simplified)\n            G[i*3:(i+1)*3] += gravity_force\n        \n        return G\n    \n    def forward_dynamics(self, q, qd, tau):\n        """Compute joint accelerations from torques"""\n        \n        M = self.compute_mass_matrix(q)\n        C = self.compute_coriolis_matrix(q, qd)\n        G = self.compute_gravity_vector(q)\n        \n        # Equation: M*qdd + C*qd + G = tau\n        # Solve for qdd: qdd = M^-1 * (tau - C*qd - G)\n        qdd = np.linalg.inv(M) @ (tau - C @ qd - G)\n        \n        return qdd\n    \n    def inverse_dynamics(self, q, qd, qdd):\n        """Compute required torques for desired motion"""\n        \n        M = self.compute_mass_matrix(q)\n        C = self.compute_coriolis_matrix(q, qd)\n        G = self.compute_gravity_vector(q)\n        \n        # Equation: tau = M*qdd + C*qd + G\n        tau = M @ qdd + C @ qd + G\n        \n        return tau\n'})}),"\n",(0,s.jsx)(e.h2,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,s.jsx)(e.h3,{id:"task-space-control",children:"Task-Space Control"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class WholeBodyController:\n    """Whole-body control for humanoid robots"""\n    \n    def __init__(self, robot_model):\n        self.robot = robot_model\n        self.tasks = []  # List of control tasks\n        \n        # Null space projector\n        self.null_space = None\n    \n    def add_task(self, task):\n        """Add a control task"""\n        self.tasks.append(task)\n        self.update_null_space()\n    \n    def update_null_space(self):\n        """Update null space projector for hierarchical control"""\n        \n        if not self.tasks:\n            self.null_space = np.eye(self.robot.num_dof)\n            return\n        \n        # Compute null space of highest priority task\n        J = self.tasks[0].jacobian\n        self.null_space = np.eye(self.robot.num_dof) - np.linalg.pinv(J) @ J\n    \n    def compute_control_torques(self, current_state, desired_tasks):\n        """Compute joint torques for whole-body control"""\n        \n        torques = np.zeros(self.robot.num_dof)\n        null_space_projector = np.eye(self.robot.num_dof)\n        \n        # Process tasks in priority order\n        for task in self.tasks:\n            # Compute task torques\n            task_torques = task.compute_torques(current_state)\n            \n            # Project onto null space of higher priority tasks\n            task_torques = null_space_projector @ task_torques\n            \n            # Add to total torques\n            torques += task_torques\n            \n            # Update null space for next task\n            if task.jacobian is not None:\n                J = task.jacobian\n                null_space_projector = null_space_projector @ \\\n                                     (np.eye(self.robot.num_dof) - np.linalg.pinv(J) @ J)\n        \n        return torques\n\nclass ControlTask:\n    """Base class for control tasks"""\n    \n    def __init__(self, name, priority=0):\n        self.name = name\n        self.priority = priority\n        self.jacobian = None\n        self.gain = 1.0\n    \n    def compute_torques(self, current_state):\n        """Compute torques for this task"""\n        raise NotImplementedError\n\nclass PostureTask(ControlTask):\n    """Maintain desired joint posture"""\n    \n    def __init__(self, desired_angles, kp=100, kd=10):\n        super().__init__("posture")\n        self.desired_angles = desired_angles\n        self.kp = kp\n        self.kd = kd\n    \n    def compute_torques(self, current_state):\n        q = current_state[\'joint_positions\']\n        qd = current_state[\'joint_velocities\']\n        \n        # PD control\n        position_error = self.desired_angles - q\n        velocity_error = -qd\n        \n        torques = self.kp * position_error + self.kd * velocity_error\n        \n        return torques\n\nclass EndEffectorTask(ControlTask):\n    """Control end-effector pose"""\n    \n    def __init__(self, desired_pose, kp=100, kd=10):\n        super().__init__("end_effector")\n        self.desired_pose = desired_pose\n        self.kp = kp\n        self.kd = kd\n    \n    def compute_torques(self, current_state):\n        # Compute end-effector Jacobian\n        self.jacobian = self.robot.compute_ee_jacobian(current_state[\'joint_positions\'])\n        \n        # Compute pose error\n        current_pose = self.robot.forward_kinematics(current_state[\'joint_positions\'])\n        pose_error = self.compute_pose_error(current_pose, self.desired_pose)\n        \n        # Velocity error (simplified)\n        velocity_error = np.zeros(6)\n        \n        # Task space control\n        wrench = self.kp * pose_error + self.kd * velocity_error\n        \n        # Convert to joint torques\n        torques = self.jacobian.T @ wrench\n        \n        return torques\n'})}),"\n",(0,s.jsx)(e.h2,{id:"-weekly-project-complete-kinematics-and-dynamics-system",children:"\ud83c\udfaf Weekly Project: Complete Kinematics and Dynamics System"}),"\n",(0,s.jsx)(e.p,{children:"Implement a comprehensive kinematics and dynamics system that includes:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Forward Kinematics"}),": Complete humanoid FK with all chains"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inverse Kinematics"}),": Numerical IK solver for arms and legs"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamics Simulation"}),": Rigid body dynamics for the whole robot"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Whole-Body Control"}),": Hierarchical task control system"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Motion Planning"}),": Trajectory generation with dynamics constraints"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This project will give you mastery over the mathematical foundations of humanoid motion control."}),"\n",(0,s.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Forward kinematics"})," transforms joint angles to end-effector poses using DH parameters and homogeneous transformations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inverse kinematics"})," solves for joint angles given desired poses using analytical or numerical methods"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rigid body dynamics"})," models forces, torques, and motion using Newton-Euler equations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-body systems"})," require careful handling of constraints between connected bodies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Whole-body control"})," manages multiple tasks hierarchically using null space projections"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Mastering kinematics and dynamics gives you the mathematical tools to control complex robotic systems with precision and physical accuracy."})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);