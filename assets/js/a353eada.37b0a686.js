"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[520],{5813:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-04-vla/week-11-humanoid","title":"Week 11: Humanoid Development","description":"Building Robots That Move Like Humans","source":"@site/docs/module-04-vla/week-11-humanoid.md","sourceDirName":"module-04-vla","slug":"/module-04-vla/week-11-humanoid","permalink":"/docs/module-04-vla/week-11-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-04-vla/week-11-humanoid.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Week 11: Humanoid Development","sidebar_position":1},"sidebar":"modulesSidebar","previous":{"title":"Week 10: Reinforcement Learning","permalink":"/docs/module-03-isaac-brain/week-10-rl"},"next":{"title":"Week 12: Kinematics & Dynamics","permalink":"/docs/module-04-vla/week-12-kinematics"}}');var o=a(4848),i=a(8453);const s={title:"Week 11: Humanoid Development",sidebar_position:1},l="Week 11: Humanoid Robot Development - Mastering Human-Like Robotics",r={},c=[{value:"Building Robots That Move Like Humans",id:"building-robots-that-move-like-humans",level:2},{value:"The Humanoid Challenge",id:"the-humanoid-challenge",level:2},{value:"Why Humanoids Are Different",id:"why-humanoids-are-different",level:3},{value:"Humanoid Design Principles",id:"humanoid-design-principles",level:2},{value:"Morphological Considerations",id:"morphological-considerations",level:3},{value:"Bipedal Locomotion Fundamentals",id:"bipedal-locomotion-fundamentals",level:2},{value:"Walking Biomechanics",id:"walking-biomechanics",level:3},{value:"Balance Control Systems",id:"balance-control-systems",level:2},{value:"Zero Moment Point (ZMP) Control",id:"zero-moment-point-zmp-control",level:3},{value:"Inertial Measurement Integration",id:"inertial-measurement-integration",level:3},{value:"Manipulation and Grasping",id:"manipulation-and-grasping",level:2},{value:"Humanoid Hand Design",id:"humanoid-hand-design",level:3},{value:"Grasp Planning for Humanoid Hands",id:"grasp-planning-for-humanoid-hands",level:3},{value:"Human-Robot Interaction Design",id:"human-robot-interaction-design",level:2},{value:"Social Navigation",id:"social-navigation",level:3},{value:"\ud83c\udfaf Weekly Project: Humanoid Control System",id:"-weekly-project-humanoid-control-system",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"week-11-humanoid-robot-development---mastering-human-like-robotics",children:"Week 11: Humanoid Robot Development - Mastering Human-Like Robotics"})}),"\n",(0,o.jsx)(e.h2,{id:"building-robots-that-move-like-humans",children:"Building Robots That Move Like Humans"}),"\n",(0,o.jsx)(e.p,{children:"Welcome to the fascinating world of humanoid robotics, where machines attempt to replicate the most complex and capable form of locomotion and manipulation known to us\u2014human movement. This week introduces the unique challenges and techniques of humanoid robot development, focusing on bipedal locomotion, balance control, and human-like interaction. You'll learn why humanoids are uniquely challenging and how to approach their development systematically."}),"\n",(0,o.jsx)(e.h2,{id:"the-humanoid-challenge",children:"The Humanoid Challenge"}),"\n",(0,o.jsx)(e.h3,{id:"why-humanoids-are-different",children:"Why Humanoids Are Different"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots differ fundamentally from wheeled or fixed-base manipulators:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class HumanoidChallenges:\n    """Key challenges in humanoid robot development"""\n    \n    def dynamic_balance(self):\n        """Maintaining stability on two legs"""\n        # Humans use ~300 muscles for balance\n        # Robots must coordinate 20+ joints in real-time\n        # Balance requires predicting and reacting to disturbances\n        pass\n    \n    def energy_efficiency(self):\n        """Humans are remarkably efficient walkers"""\n        # Human walking efficiency: ~25% of energy returned to motion\n        # Robot walking efficiency: Often <5% without optimization\n        # Energy management affects battery life and thermal constraints\n        pass\n    \n    def perception_guidance(self):\n        """Using vision and sensing for human-like awareness"""\n        # Humans integrate multiple senses seamlessly\n        # Robots must fuse IMU, vision, and tactile data\n        # Real-time processing enables adaptive movement\n        pass\n    \n    def human_interaction(self):\n        """Moving comfortably around and with humans"""\n        # Human-sized robots create unique safety concerns\n        # Social navigation requires understanding human behavior\n        # Natural movement patterns reduce user discomfort\n        pass\n'})}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-design-principles",children:"Humanoid Design Principles"}),"\n",(0,o.jsx)(e.h3,{id:"morphological-considerations",children:"Morphological Considerations"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Humanoid robot URDF structure --\x3e\n<robot name="humanoid_robot">\n  \x3c!-- Base coordinate frame --\x3e\n  <link name="base_link"/>\n  \n  \x3c!-- Legs (6 DOF each typical) --\x3e\n  <link name="left_hip_link"/>\n  <link name="left_knee_link"/>\n  <link name="left_ankle_link"/>\n  <joint name="left_hip_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_hip_link"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="100" velocity="2"/>\n  </joint>\n  \x3c!-- Additional leg joints: roll, yaw, knee, ankle pitch/roll --\x3e\n  \n  \x3c!-- Torso (2-3 DOF) --\x3e\n  <link name="torso_link"/>\n  <joint name="torso_pitch" type="revolute">\n    <parent link="base_link"/>\n    <child link="torso_link"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n  \n  \x3c!-- Arms (7 DOF each typical) --\x3e\n  <link name="left_shoulder_link"/>\n  <joint name="left_shoulder_pitch" type="revolute">\n    <parent link="torso_link"/>\n    <child link="left_shoulder_link"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n  \x3c!-- Additional arm joints: roll, yaw, elbow, wrist --\x3e\n  \n  \x3c!-- Head (2-3 DOF) --\x3e\n  <link name="head_link"/>\n  <joint name="head_pan" type="revolute">\n    <parent link="torso_link"/>\n    <child link="head_link"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"bipedal-locomotion-fundamentals",children:"Bipedal Locomotion Fundamentals"}),"\n",(0,o.jsx)(e.h3,{id:"walking-biomechanics",children:"Walking Biomechanics"}),"\n",(0,o.jsx)(e.p,{children:"Humans walk using an inverted pendulum model with step-to-step transitions:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class BipedalWalker:\n    """Simplified bipedal walking controller"""\n    \n    def __init__(self):\n        self.step_length = 0.3  # meters\n        self.step_height = 0.05  # meters\n        self.walking_speed = 0.5  # m/s\n        \n        # Walking phases\n        self.support_leg = "left"\n        self.swing_leg = "right"\n        \n        # Balance control\n        self.zmp_controller = ZMPController()\n        self.balance_feedback = BalanceFeedback()\n    \n    def plan_step(self, target_position):\n        """Plan a single step toward target"""\n        \n        # Calculate step parameters\n        current_pos = self.get_current_position()\n        step_vector = target_position - current_pos\n        \n        # Generate foot trajectory\n        foot_trajectory = self.generate_foot_trajectory(\n            start_pos=self.get_support_foot_pos(),\n            end_pos=target_position,\n            step_height=self.step_height\n        )\n        \n        # Plan center of mass trajectory\n        com_trajectory = self.plan_com_trajectory(\n            current_com=self.get_com_position(),\n            foot_trajectory=foot_trajectory\n        )\n        \n        # Check balance feasibility\n        if not self.zmp_controller.check_feasibility(com_trajectory):\n            # Adjust step for balance\n            foot_trajectory = self.adjust_step_for_balance(\n                foot_trajectory, com_trajectory\n            )\n        \n        return foot_trajectory, com_trajectory\n    \n    def generate_foot_trajectory(self, start_pos, end_pos, step_height):\n        """Generate smooth foot trajectory"""\n        \n        # Cubic spline for smooth motion\n        trajectory = []\n        num_points = 50\n        \n        for i in range(num_points):\n            t = i / (num_points - 1)\n            \n            # X position (linear)\n            x = start_pos[0] + t * (end_pos[0] - start_pos[0])\n            \n            # Y position (linear)\n            y = start_pos[1] + t * (end_pos[1] - start_pos[1])\n            \n            # Z position (parabolic for step height)\n            if t < 0.5:\n                z = start_pos[2] + 4 * step_height * t * (1 - t)\n            else:\n                z = end_pos[2]\n            \n            trajectory.append([x, y, z])\n        \n        return trajectory\n    \n    def plan_com_trajectory(self, current_com, foot_trajectory):\n        """Plan center of mass movement"""\n        \n        com_trajectory = []\n        \n        for foot_pos in foot_trajectory:\n            # Keep COM centered over support foot during single support\n            if self.is_single_support_phase():\n                target_com = [\n                    foot_pos[0],  # X aligned with support foot\n                    foot_pos[1],  # Y aligned with support foot\n                    current_com[2]  # Maintain height\n                ]\n            else:\n                # During double support, move COM toward next step\n                target_com = self.interpolate_com_position(foot_pos)\n            \n            com_trajectory.append(target_com)\n        \n        return com_trajectory\n'})}),"\n",(0,o.jsx)(e.h2,{id:"balance-control-systems",children:"Balance Control Systems"}),"\n",(0,o.jsx)(e.h3,{id:"zero-moment-point-zmp-control",children:"Zero Moment Point (ZMP) Control"}),"\n",(0,o.jsx)(e.p,{children:"ZMP represents the point where the ground reaction force acts:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ZMPController:\n    """Zero Moment Point balance controller"""\n    \n    def __init__(self):\n        self.foot_width = 0.1  # meters\n        self.foot_length = 0.25  # meters\n        \n        # ZMP stability margin\n        self.stability_margin = 0.02  # meters\n        \n        # Control gains\n        self.kp_zmp = 100\n        self.kd_zmp = 20\n    \n    def compute_zmp(self, com_position, com_velocity, com_acceleration, foot_positions):\n        """Calculate current ZMP position"""\n        \n        # ZMP equation: x_zmp = x_com - (z_com * ddx_com) / (ddz_com + g)\n        # Simplified 2D calculation\n        z_com = com_position[2]\n        ddx_com = com_acceleration[0]  # X acceleration\n        ddz_com = com_acceleration[2]  # Z acceleration\n        \n        x_zmp = com_position[0] - (z_com / (ddz_com + 9.81)) * ddx_com\n        \n        return x_zmp\n    \n    def check_stability(self, zmp_position, support_polygon):\n        """Check if ZMP is within stable region"""\n        \n        # Support polygon is convex hull of contact points\n        min_x = min(p[0] for p in support_polygon) + self.stability_margin\n        max_x = max(p[0] for p in support_polygon) - self.stability_margin\n        \n        return min_x <= zmp_position <= max_x\n    \n    def generate_balance_corrections(self, current_zmp, desired_zmp, com_state):\n        """Generate ankle torques for balance"""\n        \n        zmp_error = desired_zmp - current_zmp\n        \n        # PD control for ZMP\n        ankle_torque = self.kp_zmp * zmp_error - self.kd_zmp * com_state[\'velocity\'][0]\n        \n        return ankle_torque\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inertial-measurement-integration",children:"Inertial Measurement Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class IMU_BalanceController:\n    """Balance controller using IMU feedback"""\n    \n    def __init__(self):\n        self.imu = IMU()\n        \n        # Complementary filter for angle estimation\n        self.angle_estimate = 0.0\n        self.alpha = 0.98  # Gyro weight\n        \n        # Balance control parameters\n        self.target_angle = 0.0  # Upright\n        self.kp_balance = 50\n        self.ki_balance = 10\n        self.kd_balance = 5\n        \n        # Integral term\n        self.angle_integral = 0.0\n        self.max_integral = 10.0\n    \n    def update_balance_control(self, dt):\n        """Update balance control using IMU"""\n        \n        # Read IMU data\n        accel_data = self.imu.get_acceleration()\n        gyro_data = self.imu.get_angular_velocity()\n        \n        # Estimate angle using complementary filter\n        accel_angle = math.atan2(accel_data[1], accel_data[2])\n        gyro_angle = self.angle_estimate + gyro_data[0] * dt\n        \n        self.angle_estimate = self.alpha * gyro_angle + (1 - self.alpha) * accel_angle\n        \n        # Calculate balance error\n        angle_error = self.target_angle - self.angle_estimate\n        \n        # Update integral term\n        self.angle_integral += angle_error * dt\n        self.angle_integral = max(-self.max_integral, min(self.max_integral, self.angle_integral))\n        \n        # Calculate derivative term\n        angle_derivative = -gyro_data[0]  # Negative gyro for derivative\n        \n        # PID control\n        ankle_torque = (\n            self.kp_balance * angle_error +\n            self.ki_balance * self.angle_integral +\n            self.kd_balance * angle_derivative\n        )\n        \n        return ankle_torque\n'})}),"\n",(0,o.jsx)(e.h2,{id:"manipulation-and-grasping",children:"Manipulation and Grasping"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-hand-design",children:"Humanoid Hand Design"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Humanoid hand URDF --\x3e\n<link name="palm_link"/>\n<link name="thumb_proximal"/>\n<link name="thumb_distal"/>\n<link name="index_proximal"/>\n<link name="index_middle"/>\n<link name="index_distal"/>\n\x3c!-- Additional fingers: middle, ring, pinky --\x3e\n\n<joint name="thumb_mcp" type="revolute">\n  <parent link="palm_link"/>\n  <child link="thumb_proximal"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="0" upper="1.57" effort="10" velocity="2"/>\n</joint>\n\n<joint name="thumb_pip" type="revolute">\n  <parent link="thumb_proximal"/>\n  <child link="thumb_distal"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="0" upper="1.57" effort="5" velocity="3"/>\n</joint>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"grasp-planning-for-humanoid-hands",children:"Grasp Planning for Humanoid Hands"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class HumanoidGraspPlanner:\n    \"\"\"Grasp planning for humanoid hands\"\"\"\n    \n    def __init__(self):\n        self.hand_kinematics = HandKinematics()\n        self.force_distribution = ForceDistribution()\n        self.stability_analyzer = GraspStabilityAnalyzer()\n        \n        # Pre-defined grasp types\n        self.grasp_types = {\n            'power_grasp': self.plan_power_grasp,\n            'precision_grasp': self.plan_precision_grasp,\n            'pinch_grasp': self.plan_pinch_grasp\n        }\n    \n    def plan_grasp(self, object_geometry, object_pose, grasp_type='power'):\n        \"\"\"Plan a complete grasp for humanoid hand\"\"\"\n        \n        # Select grasp planning function\n        if grasp_type not in self.grasp_types:\n            grasp_type = 'power'\n        \n        planner = self.grasp_types[grasp_type]\n        \n        # Generate grasp candidates\n        candidates = planner(object_geometry, object_pose)\n        \n        # Evaluate grasp quality\n        best_grasp = None\n        best_score = -float('inf')\n        \n        for candidate in candidates:\n            # Check kinematic feasibility\n            if not self.check_kinematic_feasibility(candidate):\n                continue\n            \n            # Analyze grasp stability\n            stability_score = self.stability_analyzer.analyze(candidate, object_geometry)\n            \n            # Calculate overall score\n            score = self.compute_grasp_score(candidate, stability_score)\n            \n            if score > best_score:\n                best_score = score\n                best_grasp = candidate\n        \n        return best_grasp, best_score\n    \n    def plan_power_grasp(self, object_geometry, object_pose):\n        \"\"\"Plan power grasp (enclosing object)\"\"\"\n        \n        candidates = []\n        \n        # Generate grasp poses around object\n        for angle in range(0, 360, 45):  # 8 candidates\n            # Calculate hand pose\n            hand_pose = self.compute_hand_pose_for_power_grasp(\n                object_pose, angle, object_geometry\n            )\n            \n            # Calculate finger joint angles\n            finger_angles = self.compute_finger_angles_for_power_grasp(\n                object_geometry\n            )\n            \n            candidates.append({\n                'hand_pose': hand_pose,\n                'finger_angles': finger_angles,\n                'grasp_type': 'power'\n            })\n        \n        return candidates\n    \n    def plan_precision_grasp(self, object_geometry, object_pose):\n        \"\"\"Plan precision grasp (thumb and finger tips)\"\"\"\n        \n        candidates = []\n        \n        # Focus on thumb-index finger opposition\n        for approach_angle in range(0, 180, 30):  # 6 candidates\n            hand_pose = self.compute_hand_pose_for_precision_grasp(\n                object_pose, approach_angle, object_geometry\n            )\n            \n            finger_angles = self.compute_finger_angles_for_precision_grasp(\n                object_geometry\n            )\n            \n            candidates.append({\n                'hand_pose': hand_pose,\n                'finger_angles': finger_angles,\n                'grasp_type': 'precision'\n            })\n        \n        return candidates\n    \n    def check_kinematic_feasibility(self, grasp_candidate):\n        \"\"\"Check if grasp is kinematically possible\"\"\"\n        \n        # Check joint limits\n        for joint_name, angle in grasp_candidate['finger_angles'].items():\n            joint_limits = self.hand_kinematics.get_joint_limits(joint_name)\n            if not (joint_limits['min'] <= angle <= joint_limits['max']):\n                return False\n        \n        # Check for self-collisions\n        if self.hand_kinematics.check_self_collision(grasp_candidate['finger_angles']):\n            return False\n        \n        return True\n    \n    def compute_grasp_score(self, candidate, stability_score):\n        \"\"\"Compute overall grasp quality score\"\"\"\n        \n        # Factors: stability, dexterity, comfort, robustness\n        stability_weight = 0.4\n        dexterity_weight = 0.3\n        comfort_weight = 0.2\n        robustness_weight = 0.1\n        \n        dexterity_score = self.compute_dexterity_score(candidate)\n        comfort_score = self.compute_comfort_score(candidate)\n        robustness_score = self.compute_robustness_score(candidate)\n        \n        total_score = (\n            stability_weight * stability_score +\n            dexterity_weight * dexterity_score +\n            comfort_weight * comfort_score +\n            robustness_weight * robustness_score\n        )\n        \n        return total_score\n"})}),"\n",(0,o.jsx)(e.h2,{id:"human-robot-interaction-design",children:"Human-Robot Interaction Design"}),"\n",(0,o.jsx)(e.h3,{id:"social-navigation",children:"Social Navigation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class SocialNavigation:\n    """Human-aware navigation for humanoids"""\n    \n    def __init__(self):\n        self.human_detector = HumanDetector()\n        self.intent_predictor = HumanIntentPredictor()\n        self.comfort_analyzer = ComfortAnalyzer()\n        \n        # Social navigation parameters\n        self.personal_space = 0.6  # meters\n        self.approach_angle_preference = 45  # degrees\n    \n    def plan_social_trajectory(self, start_pose, goal_pose, human_positions):\n        """Plan trajectory considering human presence"""\n        \n        # Detect humans in environment\n        humans = self.human_detector.detect_humans()\n        \n        # Predict human intentions\n        human_intents = {}\n        for human_id, human_pose in humans.items():\n            human_intents[human_id] = self.intent_predictor.predict_intent(\n                human_pose, goal_pose\n            )\n        \n        # Generate socially aware path\n        trajectory = self.generate_social_path(\n            start_pose, goal_pose, humans, human_intents\n        )\n        \n        return trajectory\n    \n    def generate_social_path(self, start, goal, humans, intents):\n        """Generate path that respects social norms"""\n        \n        # Use RRT or similar planner with social cost function\n        planner = SociallyAwareRRT(\n            start=start,\n            goal=goal,\n            humans=humans,\n            intents=intents,\n            personal_space=self.personal_space\n        )\n        \n        path = planner.plan()\n        \n        # Smooth path for natural movement\n        smoothed_path = self.smooth_trajectory(path)\n        \n        return smoothed_path\n    \n    def compute_social_cost(self, position, humans, intents):\n        """Compute social cost of being at a position"""\n        \n        total_cost = 0\n        \n        for human_id, human_pos in humans.items():\n            distance = np.linalg.norm(position - human_pos)\n            \n            # Personal space violation\n            if distance < self.personal_space:\n                space_cost = (self.personal_space - distance) ** 2\n                total_cost += space_cost\n            \n            # Intent-based cost\n            intent = intents[human_id]\n            if intent == \'walking_toward\':\n                # Give way to approaching humans\n                total_cost += 2.0 / max(distance, 0.1)\n            elif intent == \'standing_still\':\n                # Respect stationary humans more\n                total_cost += 1.0 / max(distance, 0.1)\n        \n        return total_cost\n'})}),"\n",(0,o.jsx)(e.h2,{id:"-weekly-project-humanoid-control-system",children:"\ud83c\udfaf Weekly Project: Humanoid Control System"}),"\n",(0,o.jsx)(e.p,{children:"Build a complete humanoid control system that demonstrates:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bipedal Locomotion"}),": Implement walking controller with balance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Manipulation"}),": Create grasp planning for humanoid hands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Whole-Body Control"}),": Coordinate arms, legs, and torso"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Social Navigation"}),": Navigate considering human presence"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"VLA Integration"}),": Add basic voice command following"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"This project will give you hands-on experience with the unique challenges of humanoid robotics."}),"\n",(0,o.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Humanoid robots"})," require sophisticated balance control using ZMP and IMU feedback"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bipedal locomotion"})," involves complex phase coordination between legs and center of mass"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dexterous manipulation"})," needs careful grasp planning considering hand kinematics"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Human-robot interaction"})," demands social awareness in movement and behavior"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Whole-body coordination"})," is essential for natural, human-like motion"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Mastering humanoid development opens the door to robots that can work seamlessly in human environments, performing tasks that require human-like dexterity and awareness."})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>s,x:()=>l});var t=a(6540);const o={},i=t.createContext(o);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);